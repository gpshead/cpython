# Background

You are helping a CPython core team member work on the implementation of the
Python language runtime and standard library itself.

Use tools like `gh` to get information about an issue or PR in the repo.
Including using the GraphQL API via `gh` when appropriate.

Source files in this repo can be very long.  Check their size or number of
lines with a tool before deciding strategically if you should read an entire
file.  Changes will be often focused on specific areas of a files instead
of needing the entire thing in context.

# Extra context

* ALWAYS check for and load a `CLAUDE.local-$PR_NUMBER.md` file after you are told a PR number.
* Keep this engineering notebook file of relevant knowledge up to date towards the end of a task as you learn more and make changes.

# Source code

* The runtime is implemented in C as are many of the core types and extension modules
* The Python standard library itself lives in the `Lib/` tree
* Python stdlib C extension modules live in the `Modules/` Tree
* Python builtins, objects, and the runtime itself live in `Objects/` and `Python/`
* Never edit files in a `**/clinic/**` subdirectory; those are generated by argument clinic
* Unittests for everything live in the `Lib/test/` tree
   * `Lib/zipfile/` contains the code for the stdlib `zipfile` module
   * `Lib/test/test_zipfile**` are tests for `zipfile`
   * `Modules/_csv.c` contains the code for the stdlib `csv` module
   * `Lib/test/test_csv.py` are tests for `csv`
* Header files are in the `Include/` tree
* Documentation is written in .rst format in `Doc/`

## Coding style

* For C, follow https://peps.python.org/pep-0007/. For Python, follow PEP-8.
* Prefer to be consistent with existing surrounding code style unless asked to do otherwise.
* NEVER leave trailing whitespace on any line.
* ALWAYS preserve the newline at the end of files.
* We do not autoformat _most_ code in this codebase. If the user asks you to run ruff format on a specific file, it can be found in `Doc/venv/bin/ruff`.

## Building

ONLY build outside of the main repo directory.

* Use sub-agents when running configure and make build steps
* let `SRC_DIR=$(pwd)` and `BUILD_DIR="$SRC_DIR"/../b/`
* Setup: `mkdir "$BUILD_DIR" && (cd "$BUILD_DIR" && "$SRC_DIR"/configure --with-pydebug)`
* `make -C "$BUILD_DIR" -j $(nproc)` will rebuild
* Let `BUILT_PY="$BUILD_DIR"/python`
* Add a ".exe" suffix to `BUILT_PY` when running on macOS (you can determine this via `uname`)

## Running our built Python and tests

* Use sub-agents when running tests
* `$BUILT_PY` will run the interpreter we've built
* `$BUILT_PY -m test test_zipfile -j $(nproc)` will properly run all `Lib/test/test_zipfile` tests
* Individual test files can be run directly using `"$BUILT_PY" Lib/test/test_csv.py` style
* `make -C "$BUILD_DIR" clinic` will regenerate argument clinic generated code. Do this after you've edited a corresponding input .c file in a way that changes a C extension module function signature or docstring
* `make -C "$BUILD_DIR" test` will run the entire test suite. Do that sparingly via a sub-agent. focus on specific tests first and ask before running the entire test suite.
* Some tests are packages rather than a single .py file. These require `load_tests()` logic in their `test_package/__init__.py` file in order to work via `$BUILT_PY -m test` commands.
* To select specific tests when running some via `-m test` you can pass a `--match nameglob` pattern.

## Linting

* Use sub-agents when running these steps.
* `make -C "$BUILD_DIR" patchcheck`
* For documentation changes `make -C Doc check`

# Guiding Mantras

Use extended thinking when you feel unsure.  Ask questions when you are still not confident.
